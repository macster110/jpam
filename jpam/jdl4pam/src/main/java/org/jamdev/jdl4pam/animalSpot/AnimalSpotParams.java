package org.jamdev.jdl4pam.animalSpot;

import java.util.ArrayList;
import org.jamdev.jdl4pam.genericmodel.GenericModelParams;
import org.jamdev.jdl4pam.transforms.DLTransform.DLTransformType;
import org.jamdev.jdl4pam.transforms.DLTransfromParams;
import org.jamdev.jdl4pam.transforms.SimpleTransformParams;
import org.jamdev.jdl4pam.transforms.jsonfile.DLTransformsParser;
import org.jamdev.jpamutils.JamArr;
import org.json.JSONObject;

/**
 * Parameters for running the deep learning algorithm
 * <p>
 * Note that parameter names are in python format to keep them 
 * consistant with the Python code. 

 * 
 * @author Jamne Macaulay 
 *
 */
public class AnimalSpotParams extends GenericModelParams {

	//settingss for bats used by christian
	//	17:22:24|D|dataOpts: {
	//    "samplingrate": 256000,
	//    "preemphases": 0.98,
	//    "n_fft": 256,
	//    "hop_length": 8,
	//    "n_freq_bins": 256,
	//    "fmin": 40000,
	//    "fmax": 100000,
	//    "freq_compression": "linear",
	//    "min_level_db": -100,
	//    "ref_level_db": 0
	//}


	/**
	 * The default segment length for the classifier. 
	 */
	public double seglen = 11.0; //milliseconds  


	/**
	 * Create a default set of Sound Spot params. 
	 */
	public AnimalSpotParams() {
		defaultParams();
	}


	/**
	 * Constructor for SoundSpotParams which parses a raw string extracted from a Sound Spot model. 
	 * @param rawString - the raw parameters string from the model. 
	 */
	public AnimalSpotParams(String rawString) {
		parseRawString(rawString); 
	}

	/**
	 * Get the parameters from a JSOn string if the transform type is known.   
	 * @param dlTransformType - the transform type.
	 * @param jsonObjectParams - JSON object containing the parameters.  
	 * @return the DLTransfromParams generated by the JSONObject. 
	 */	
	public static DLTransfromParams parseDLTransformParams(DLTransformType dlTransformType, JSONObject jsonObjectParams) {
		return DLTransformsParser.parseDLTransformParams(dlTransformType, jsonObjectParams); 
	}


	/**
	 * Parse the transform parameters from the raw metadata string. 
	 * @param rawString - the raw metadata string. 
	 * @return a list of transform parameter objects.
	 */
	public static ArrayList<DLTransfromParams>  parseTransfromParams(String rawString) {
		 ArrayList<DLTransfromParams>  params =  DLTransformsParser.parseTransfromParams(rawString);
		
		//SoundSpot is ever so slightly different as it includes the clamp transform with the normalisation so need to add it
//		//also add the clamp here - it is separate in PG but integrated in AnimalSpot. 
		 for (int i =0; i<params.size(); i++) {
			 if (params.get(i).dltransfromType==DLTransformType.SPECNORMALISE) {
				 //if the transform is a mindB then add the clamp....
				 params.add(i+1, new SimpleTransformParams(DLTransformType.SPECCLAMP, 0.0, 1.0)); 
				 break; 
			 }
		 }
		 
		 
		 
		 return params; 
	}

	/**
	 * Parse a parameters string from the SoundSpotModel. 
	 * @param rawString - the raw string. 
	 */ 
	@Deprecated
	private void parseRawString(String rawString) {
		
		System.out.println(rawString); 

		//load the transfroms from the string metadata
		this.dlTransforms =   parseTransfromParams( rawString); 

		//first parse the transforms.
		JSONObject jsonObject = new JSONObject(rawString);

		//		//now get the class names. 
		String classString = jsonObject.getString("class_info"); 
		
		//ugly but works - cannot use 
		String classNamesRaw = classString.substring(classString.indexOf("name_class :")+12, classString.length()-1);
		
		String[] classNames; 
		if (!classString.contains(": 0,")) {
			//System.out.println("ANIMAL_SPOT class names format 1"); 
			//Format 1
			//{num_class : 6, name_class : daub,mnatter,noct,pipi,sero,noise};
			

			//		int nClass  = jsonObjectParams.getInt("num_class"); 
			//		String classNamesRaw  = jsonObjectParams.getString("name_class"); 
			classNames = classNamesRaw.split(",");
			for (int i=0; i<classNames.length; i++) {
				classNames[i]=classNames[i].trim(); //remove whitespace
			}
		}
		else {
			classNamesRaw = classNamesRaw.trim();
			classNamesRaw = classNamesRaw.substring(1, classNamesRaw.length()-1);
			
			//System.out.println("ANIMAL_SPOT class names format 2: " + classNamesRaw); 

			String[] classNameStructs = classNamesRaw.split(",");
			
			int[] index = new int[classNameStructs.length]; 
			classNames = new String[classNameStructs.length]; 
			for (int i=0; i<classNameStructs.length; i++) {
				String[] nameBits = classNameStructs[i].split(":"); 
				
				index[i] =  Integer.valueOf(nameBits[1].trim()); 
				
//				System.out.println(nameBits[0]); 
						
				classNames[i]=nameBits[0].trim(); 
				//remove the ' ' bits
				classNames[i]=classNames[i].substring(1, classNames[i].length()-1).trim(); 

			} 
			
			//now gave to order the array by the index
			classNames = JamArr.rearrange(classNames, index); 
		}
		
		this.classNames = classNames; 

		JSONObject jsonObjectParams = new JSONObject(jsonObject.getString("seg_size")); 
		double segSize  = jsonObjectParams.getInt("size_ms"); 

		this.seglen = segSize; 


		//must order these in the correct way!l 
		//			switch (jsonstrings[i]) {
		//			case "min_level_db":
		//				this.min_level_dB = jsonObject.getDouble("min_level_db"); 
		//				break;
		//			case "n_freq_bins":
		//				this.n_freq_bins = jsonObject.getInt("n_freq_bins");
		//				break;
		//			case "preemphases":
		//				this.preemphases = jsonObject.getDouble("preemphases");
		//				break;
		//			case "ref_level_db":
		//				this.ref_level_dB = jsonObject.getDouble("ref_level_db");
		//				break;
		//			case "n_fft":
		//				this.n_fft = jsonObject.getInt("n_fft");
		//				break;
		//			case "fmin":
		//				this.fmin = jsonObject.getDouble("fmin");
		//				break;
		//			case "fmax":
		//				this.fmax = jsonObject.getDouble("fmax");
		//				break;
		//			case "sr":
		//				this.sR  = jsonObject.getFloat("sr");
		//				break;
		//			case "hop_length":
		//				this.hop_length = jsonObject.getInt("hop_length");
		//				break;
		//			case "freq_compression":
		//				this.freq_compression = jsonObject.getString("freq_compression"); 
		//				break;
		//			}

	}
	

	@Override
	public String toString() {
		String string = ""; 
		
		string += "***********\n"; 
		
		string += "Segment length: " + seglen + " milliseconds\n"; 
		
		string += "***********\n"; 
		string += "No. classes: " + this.classNames.length + "  \n"; 
		for (int i=0; i<this.classNames.length; i++) {
			string += classNames[i] + "\n"; 
		}

		string += "***********\n"; 
		for (int i=0; i<this.dlTransforms.size(); i++) {
			string += dlTransforms.get(i).toString() + "\n"; 
		}

		string += "***********\n"; 

		return string; 
	} 



	/**
	 * Create a default set of paramters. this can be for testing etc. 
	 */
	private void defaultParams() {
		//

		//The FFT length for the spectrogram in bins

		int n_fft = 256;

		/**
		 * The FFT hop in sample bins.
		 */
		int hop_length = 8;

		/**
		 * The sample rate to interpolate or decimate to in samples per second. i.e.
		 * this is the sample rate of the training data.
		 */
		float sR = 256000;

		/**
		 * The pore emphasis factor. This dictates how much the lower frequences in the
		 * wave data are attenuated.
		 */
		double preemphases = 0.98;

		/**
		 * The minimum dB level for normalising the dB spectral amplitudes.
		 */
		double min_level_dB = -100;

		/**
		 * The reference dB level for normalising the dB spectral amplitudes.
		 */
		double ref_level_dB = 0;

		/**
		 * Minimum value to clamp spectrogram to after normalisation.
		 */
		double clampMin = 0;

		/**
		 * Maximum value to clamp spectrogram to after normalisation.
		 */
		double clampMax = 1;

		/**
		 * The minimum frequency to interpolate the spectrogram image from.
		 */
		double fmax = 100000;

		/**
		 * The maximum frequency to interpolate the spectrogram image from.
		 */
		double fmin = 40000;

		/**
		 * The number of vertical bins to interpolate the spectrogram image to.
		 */
		int n_freq_bins = 256;

		/**
		 * The type of frequency compression ot nuse.
		 */
		String freq_compression = "linear";


		ArrayList<DLTransfromParams> dlTransformParamsArr = new ArrayList<DLTransfromParams>();

		// now generate a;l the parameter class
		SimpleTransformParams dlTransfromParams;

		//waveform transforms. 
		dlTransformParamsArr.add(new SimpleTransformParams(DLTransformType.DECIMATE, sR)); 
		dlTransformParamsArr.add(new SimpleTransformParams(DLTransformType.PREEMPHSIS, preemphases)); 
		dlTransformParamsArr.add(new SimpleTransformParams(DLTransformType.SPECTROGRAM, n_fft, hop_length)); 
		dlTransformParamsArr.add(new SimpleTransformParams(DLTransformType.SPECCROPINTERP, fmin, fmax, n_freq_bins)); 
		dlTransformParamsArr.add(new SimpleTransformParams(DLTransformType.SPEC2DB, min_level_dB)); 
		dlTransformParamsArr.add(new SimpleTransformParams(DLTransformType.SPECNORMALISE, min_level_dB, ref_level_dB)); 
		dlTransformParamsArr.add(new SimpleTransformParams(DLTransformType.SPECCLAMP, clampMin, clampMax)); 

		this.dlTransforms = dlTransformParamsArr; 

	}







}
